package _Bonus_test;

public class _n_test {

	public static void main(String[] args) {
		
		// 셀프 넘버 = 제네레이터가 없는 숫자
		//문제. 1이상이고 5000보다 작은 모든 셀프 넘버들의 함을 구하기
		
		//사고과정.
		// 예를 들어 십의 자리이면
		// a + b + ab = c 의 형태로 만들 수 있다.
		// ab는 c의 제네레이터라고 표현, d(ab)=c라고 표현
		// 먼저, 일의자리인 경우는
		//  1*a+a 의 형태만 성립 가능
		// a의 자리에는 1~9까지 들어갈 수 있다.
		// 그럼 2a는 c이므로, 2의 배수는 모두 제네레이터임을 알 수 있다.
		// 즉 2으로 나눴을 때 나머지가 없는 경우는 모두 제네레이터임  -> 제외 조건 1(한자리)
		// 10번대인 경우는....
		// 10 -> 1 + 0 + 10 =11
		// 11 -> 1 + 1 + 11 = 13    11~29 홀수만
		// 12 -> 1+2+12=15  .... 와 같이 홀수인 경우가 다 제네레이터가 되는 것을 확인
		// 20번대는 
		// 20=22, 21=24,,,, 짝수만    24~40 짝수만
		// 30번대는 33, 35 ,,, 홀수만 33~51 홀수만
		// 99 -> 117
		// 즉 두자리수의 경우에는 십의자리가 홀수면 홀수만 제네레이터, 짝수면 짝수만 제네레이터 확인 -> 제외조건 2(십의자리)
		// 세자리인 경우는 
		// 100 -> 101,  101->103  ,,, 백의자리 홀-십의자리 짝: 홀수만,,
		// 110 -> 112, 111->114 ,,,  백의자리 홀-십의자리 홀 : 짝수만 ,,,
		// 198->216, 199->218 ,,, 백의자리 홀-십의자리 홀 : 짝수만 ,,,
		// 100의자리인 경우는 십의자리가 짝수면 홀수만, 십의자리가 홀수면 짝수만 제네레이터인 것 확인 -> 결론1
		// 200 -> 202, 201 -> 204 ,, 백의자리 짝-십의자리 짝: 짝수만,,
		// 210 -> 213, 211 -> 215,,,  백의자리 짝-십의자리 홀:홀수만,,,
		// 200의자리인 경우는 십의자리가 짝수면 짝수만, 홀수면 홀수만 제네레이터 확인 -> 결론2
		// 900 -> 909 ,,,, 998-> ,999->1026
		// 최종적으로 백의자리 : 백의자리가 홀수인 경우는 십의자리(짝.홀)의 반대경우 
		//                  / 백의자리가 짝수인 경우는 십의자리(짝.홀)와 동일 경우 제네레이터  
		// 더 간단히 말하면, 해당 값의 백의자리, 십의자리의 합이 홀수면 홀수만, 짝수면 짝수만 제네레이터 -> 제외조건 3(백의자리)
		// 1000의자리인 경우
		// 1000 -> 1001, 1002 -> 1005  홀-짝-짝 : 홀의 경우만
		// 1010 -> 1012  / 5000 홀의경우  / 4999 :  짝수만
		// 천,백,십의 합이 홀수면 홀수만, 짝수면 짝수만		-> 결론 3
		
		// 3333
		
		// 최종적으로 두자리, 세자리, 네자리는 -> 일의자리 제외 합에 따라가고, 일의자리는 짝수 아닌것만
		
		// 1부터 5000까지중 제외조건 빼고 더하기
		int sum = 0;
//		int a =1234;
//		sum = a/1000+(a%1000)/100+(a%100)/10+a%10 + a;
//		System.out.println(sum);
		
		
		
		int bb=0;
		int summ=0;
		for (int i = 1; i <= 5000; i++) {
			for (int j = 0; j <= 10000; j++) {
				sum = (j/1000)+(j%1000)/100+(j%100)/10+j%10+j;
					if(i==sum) {
						bb++;
				}
			}
			if(bb!=0) {
				summ+=i;
				bb=0;
			}
		}
		System.out.println(summ);
	}

}
// 1227365

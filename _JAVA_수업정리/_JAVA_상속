<상속과 인터페이스>
양념장 class
--> 내용을 상속받아서 오징어 class / 쭈꾸미 class / 낙지 class 가 됨

상속의 장점 
-> 유지보수가 좋다.(서브클래스에서 중복되는 코드를 슈퍼클래스에 정의해놓았기 때문에 한 부분만 수정을 해도 됨)
-> 코드의 중복이 적다.(상속받아 쓰니까 테이블이 여러개여도 중복되는 코드의 부분이 줄어듦)*****
-> 통일성이 있다.(동일한 변수, 메서드로 정의되어 접근이 용이함 / 변수, 메서드명 통일)

즉, 상속은 여러 class에서 사용되는 동일한 코드의 멤버변수, 메소드를
통일해서 하나의 class에 만들어 놓고, 각각에게 상속해주는 형식.(Super class가 Sub class에게!)
ex) DAO 클래스마다 드라이버로드, 커넥션자원얻어오는 코드, DB에 접근하는 코드는 모두 동일
    -> 이러한 내용을 하나의 class에 작성하여 모든 DAO 클래스에서 사용할 수 있게 해줌

<Super class> - super					<Sub class> - this
----------------------------			
DB info class		   		<-------   IdeaDAO - ideabank table CRUD
			   				<-------   MemberDAO - member table CRUD
멤버변수			   			<-------   Event DAO - event table CRUD
public boolean conn(){
}  // 커넥션 자원 얻어오는 메서드
public void init(){
}  // 드라이버로드 메서드
-----------------------------
=> Sub class가 Super class보다 큰범위(Super class를 확장해서 Sub class를 만들수 있음)
=> Super class만 오라클 접근의 비밀번호를 가지고 있을 때 에러가 발생하면 Super class만 수정하면 됨
=> 자바에서는 하나의 Super class만 상속받을 수 있음
      (단일상속만 가능)(Sub class는 하나의 Super class만 가질 수 있다.)*****

Super class자원을 확장해서 Sub class를 만든다 - > is a
Sub class에서 Super class자원을 포함하고 있다 - > has a

1. 개념 이해하기 -> Super class를 확장해서(멤버변수와 메서드) Sub class를 만든것이 상속이다.
2. 특징 -> 단일상속만가능, 유지보수가 좋다, 중복된 코드를 줄일 수 있다, 통일성을 줄 수 있다.(부모클래스의 입장에서 !)
3. 상속을 이용하여 설계할 때 'is a' 관계로 주로 설계함
4. 메소드 오버라이드 -> Super class로부터 상속받은 메서드를 Sub class에서 재정의하여 사용하겠다는 것
5. 객체지향언어의 특징 
-> 추상화(클래스 만드는 것), 캡슐화(은닉화, 내부자원 숨김), 상속(Super클래스가 Sub클래스로 확장), 
    다형성(Super클래스 타입의 변수가 Sub클래스의 객체의 주소를 저장할 수 있다.)(부모로 접근하여 다형성 형성)

** 오버라이드된 메소드는 자식 클래스에 있는 메소드가 우선임 !
자식 통하여 부모로 접근 가능 ! 
부모 통하여 자식 접근 불가능 !
@Override 이 표시로 컴파일러에게 오버라이드된 메소드임을 알려줌 !
-------------------------------------------------
상속
  1. 정의 : super class의 자원(멤버변수, 메서드)을
             sub class가 상속받아 sub class를 정의한것
  2. 특징 : 단일 상속, 중복코드제거,유지보수, 통일성(업무의 통일성에 기여할 수 있음 - 메서드명,멤버변수명 동일, 모두가 같은 기능으로 작업 가능)
메서드오버라이드
  - sub class 자원 중 메서드를 서브클래스에서 재정의
추상메서드와 추상클래스
-------------------------------------------------
다형성
  - 하나의 변수가 다양한 타입의 객체의 주소를 저장
  - 예) 상속 관계에서 슈퍼클래스 변수로 서브클래스
         객체에 접근 가능
up 
is a 관계
   - A는 B이다.   슈퍼클래스를 상속받아 B가 되었다.
-------------------------------------------------
상속의 사용(CASE)
1. 상속의 'is a 관점' ->  ex. 동물원의 super class를 가지고 호랑이, 원숭이의 동물 sub class를 만들었다.(이용하여 새로 정의)
          +
2. 상속의 '다형성 특징'을 이용하여 super class 변수로 sub class 객체 참조(->응집도를 낮추기 위해서 사용)
   ( sub class의 정보 수정시에 변수의 타입은 super class이므로 저장하는 객체(수정된 sub class)만 바꿔주면 되기 때문에 
     코드 작성에 유용)


추상메소드가 하나라도 존재하면 무조건 추상 클래스가 되어야함
추상메소드는 메소드 선언은 하였으나 구현은 되지 않은 상태임
-> super class에서 public abstract void kkk();   => 이런식으로 메소드 정의는 되어있지만 구현은 안한상태
-> sub class는 이 메서드에 대해서 override를 반드시 해야함
-------------------------------------------------
service 패키지 역할(현재)
클라이언트 요청대로 데이터베이스 접근
콘솔에 띄워주기 (T(text)U(user)I(interface))
서비스차원에서 view에 관련된 기능만 따로 -> 자바에서 제공하고 있는 그래픽적 요소 사용(GUI로,,)

JFrame super class
     ㅣ	<상속>(자바 awt, swing package제공)   -  is a
     V	
Mainframe

sub class
기능 implements(구현) 		-	has a(Mainframe은 이러한 기능을 가지고 있다.)
	- Action Listener(인터페이스, interface - 자바에서 제공 / 이벤트 동작 처리 기능제공)
	
	
상속받은 sub class에 있는 다른 기능들+CRUD기능... 의 상황에서	
중복된 코드를 super class로 만들어서 이를 상속받는 'is a 관계'로 코드를 만들자는 컨셉
CRUD의 기능만을 가지고 있는 별도의 무언가를 만들려고 하는 것.	(코드 수정 적게, 유지보수 편리)
(기능 별도 정의 -> 응집도를 낮추기 위해서 *****)
=> 클래스: CRUD로 함
   interface: CRUD를 정의만 하고 있음(실제 구현은 X) 
=> 클래스보다 인터페이스를 사용하는 것이 응집도를 낮추는것에 효과적이다
-> 이 interface를 구현받아서 DAO를 만들어짐

인터페이스로부터 기능을 구현받은 sub class는 인터페이스만 신경쓰면 됨
-------------------------------------------------
ex)
Zooinfo(Super) 
------------------
String name / eat()
     ㅣ	<상속, extends> - is a 관계(통일성, 중복된 코드 제거)
     V	
Tiger(Sub)		<- implementes(interface를 통하여 구현받도록)
------------------
MemberDAO m				 => why? 의존도를 낮추기 위해서.(Tiger가 외부의 소스의 수정에 대해서 최소한의 수정만 이루어짐)						
 = new OMember();   => 인터페이스타입의 변수, 구현받은 OMember에 대한 객체(필요한 객체만을 생성)(다형성)
   					=> tiger는 객체만 바꾸면 되니까 의존도를 낮췄다고 표현할 수 있음
 -> add 나 del의 기능이 변경되면, interface로부터 구현받은 OMember만 수정하면 됨
 => 결과적으로 interface를 사용하여 의존도를 낮출 수 있다 !!
 

public interface MemberDAO(){		-> 인터페이스는 추상 메소드만 가질 수 있음(기능만 정의하는 것 !)
	public void add();
	public void del();
}

public void OMember implements(구현받음을 의미함) MemberDAO {	-> interface에서 구현받은 것을 실제 동작하는 객체를 만드는 것
	@override
		add(){		-> add 기능을 override를 통하여 재정의, 구현
		}
	@override
		del(){		-> del 기능을 override를 통하여 재정의, 구현
		}	
}

인터페이스로부터 구현? 
 - 필요한 기능만을(ex. CRUD) 따로 정의만 하여(인터페이스에 추상메소드만 가능) 그 기능을 클래스가 구현받아 재정의해서(반드시) 실제 사용가능하게 함
슈퍼클래스로부터 상속? 
 - 슈퍼클래스의 자원(멤버변수, 메서드)을 정의해놓고 서브클래스가 상속받아 서브클래스가 정의됨(자원을 직접적으로 사용 가능, 반드시 재정의 필요 X)
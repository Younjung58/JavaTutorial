<JVM>
source: 원시파일(소스)(원시 프로그램) -> 사람이 작성한 소스(확장자 .java => src폴더에 저장)
사람이 작성한 코드를 2진수로 바꾼것(기계어 번역(컴파일), 0과1의 조합)을 컴퓨터는 보는 것.
ex) 'A' -> 64 -> 1000000(기계어 번역)
=> 이를 '목적 프로그램'이라고 함(기계가 이해가능한 언어로 구성)(확장자 .class => bin폴더에 저장)
=> 목적프로그램만 배포해도 실행만 가능함(소스는 배포하지 않음. 실행파일만 배포)
=> 즉 원시프로그램의 목적은 '개발' / 목적프로그램의 목적은 '컴퓨터에 실행'
(* 번외 * 언어의 종류: 컴파일(자바, 원시프로그램을 컴파일해서 목적프로그램으로 만드는 것이며 목적프로그램을 실행하는 것.
			자바에서 작성한 소스를 ctrl+f11을 통하여 실행해봄, 속도면에서 인터프리터보다 빠른 장점) 
	vs 인터프리터(자바스크립트, 개발된 즉시 그 소스를 공개, 개발환경에 유동적으로 적응가능한 장점))
( 자바스크립트는 컴파일 언어가 아님 )
=> 즉, 'Ctrl+f11'는 컴파일 후 프로그램을 실행하라는 의미

자바(JAVA): JDK(Development, 자바 개발시 필요한 것, , 기본 제공되는 class, 개발에 필요한 library(arraylist, scanner,,등)) 
	/ JRE(JVM)(Runtime, 목적프로그램을 실행시키기 위한 것)

목적프로그램은 실행중인가? NO!
=> 목적프로그램은 원시프로그램을 기계어로 번역해 놓아서 컴퓨터가 실행하기 위한 것
=> 실행중이라는 것은 '주기억장치(메모리, RAM)에 상주하고 있다는 것'
=> 윈도우 탐색기로 검색하는 것은 하드디스크(보조기억장치)내에서 검색하는 것

** 키워드 : 원시, 목적, 실행

--- 주기억장치 내에서 --- 
-RunTime-
Ctrl+f11 = 컴파일(번역)+실행(Thread)
Thread(코드를(목적프로그램을) 실제 실행하는 것)
실행 => cpu(중앙처리장치, 명령어(메서드처리.연산자)),RAM(저장공간, 변수 저장 / thread가 필요한 값을 저장하거나 인출) 이 필요
      => 실행중인 프로그램을 종료하여 메모리가 비워지면, cpu가 할 일이 적어짐
(보통은 원시class하나당 목적프로그램 1개 / 중첩 class일 경우 원시파일은 1개, 목적프로그램은 2개일 수 있음)

=> 실제 프로그램의 코드를 실행하는 역할: Thread(싱글Thread vs 멀티Thread)
=> 프로그램을 쪼개서 Thread로 나뉘어진다.(즉, 프로그램이 큰 의미, 그 안에 Thread단위로 존재)

Thread가 자바에서 가장 처음 실행시키는 코드는 'main method'이다.

ex. 목적프로그램에
main.class
mge.class
member.class
이 보조기억장치에 존재
-> 프로그램 실행하여 주기억장치로 가져오는 것을 '클래스로드'라고 함(소스코드 가져옴)

JVM구조 = > Stack(메서드 Call, FILO, 지역변수 저장)
	/ Heap(객체(인스턴스)의 생성, 사용, 소멸)
	(객체를 만들었는데 사용하지 않으면 메모리누수발생, 이를 자바는 GC(Garbage Collector)가 삭제해줌)
	/ Method영역 : 소스파일, 멤버변수, Static(공용변수=>객체를 만들지 않아도 사용이 가능함(접근이 가능))
				         l=>  '접근제어자 > Static' (즉, 접근제어자에서 public or default 권한을 부여받아야지만, 사용가능)
thread1, thread2가 있을 때(실행 2개)
=> method, heap영역은 공통으로 사용할 수 있는 영역이다(동시 접근시에 위험성을 가질 수 있다.)
=> stack은 그 안을 개별적으로 사용

ex. a static / b static이 있을 때, thread1과 thread2는 a, b를 둘다 사용할 수 있다.(완전 노출된 영역임)
    stack은 thread1의 a / thread2의 b 이런 형태로 존재

final(상수) = > 값이 바뀌지 않음(처음에 한번 값이 세팅되면(결정되면) 그다음에 값을 바꿀 수 없다.)
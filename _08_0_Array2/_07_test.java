package _08_0_Array2;

import java.util.Iterator;

public class _07_test {

	public static void main(String[] args) {
		/*
		 * 1 1 0 2
		 * 3 2 1 2
		 * 0 0 3 2
		 * 4 4 4 4 
		 * 2 4 3 1
		 * 2 4 1 3
		 */
		
		//7. 위와 같은 게임 배열에서 같은 번호가 세로로 연속 3개 이상이면 제거가 가능하다.
		// 제거가 가능한 블록의 좌표를 출력하시오 
		
		//사고 과정.
		// 먼저, 세로에 연속 3개가 있는것을 확인한다는 것을 포인트로 두어 생각해야할 것.
		// 즉, 열은 고정하고 행을 내려가면서 순차적으로 비교해야함.
		// 따라서 배열의 출력 과정을 열(바깥 for문)->행(안쪽 for문)의 순서대로 해야함   - 사고 1
		// 그럼 그렇게 출력하면서 3개 이상인지를 어떻게 비교할까?
		// 먼저 3개이상인지 count를 해줄 정수가 하나 필요하므로 선언(cnt)
		// 또한 3개 이상의 경우를 판별해야함(if문이 필요하다)
		// 판별할때, 지금 열에서 다음 행의 값이랑 같은 경우를 연속적으로 세어주어야하므로
		// 배열의 반복시, 안쪽인 행의 반복을 전체 배열길이보다 
		// 1작은 부분까지만 하고(1작은 부분이 마지막 부분이랑 비교됨),     			- 사고 2
		// 같을때는 count를 1씩 증가(if)/다르면(else) 초기화를 해서 연속적으로 count될 수 있게 설정   - 사고 3
		// 그 후, count가 3이상 되었을 때 제거대상이므로(if count 3이상)
		// 그 값을 제거대상으로 잡고, 해당 좌표를 출력하되, 연속되는 모든 좌표를 출력해야함..(즉 연속적 번호가 4개여도 모두 출력)
		// 여기서 어떻게 또 연속적인 부분을 따져서 출력할 것인가라는 고민...	
		// 제거대상과 번호가 같을때 좌표를 출력하되, 다른 번호가 나오는 즉시 for문을 멈추면될 것이라 생각(break사용)  -사고 4
		// 하지만, 단순히 break만을 사용하면, 3이상인 경우가 여러번이 성립되어 여러번 좌표가 출력됨..고민..  
		// 다른 숫자가 나왔을때 단순히 break전에, count값을 1로 초기화하면서			- 사고 5
		// 그 다음 반복해서 비교할 j의 값을, 마지막으로 같은 값이 나온 부분부터 다시 비교되도록 설정하면 됨(j=k)
		// 다만! j는 반복문에 들어갈때마다 1씩 증가되는 것을 고려하여, 그 전에 j값을 대입하는 것이므로 j=k-1로 최종 사고 완료. -사고 6
		
		int[][] a = {{1,1,0,2},
				     {3,2,1,2},
				     {0,0,3,2},
				     {4,4,4,2},
				     {2,4,3,2},
				     {2,4,1,3}};
		
		int ers = 0;
		int cnt = 1;
		
		
		for (int i = 0; i < a[0].length; i++) {				// 사고 1
			for (int j = 0; j < a.length-1; j++) {			// 사고 2
//				System.out.print(a[j][i]+" ");
				if(a[j][i]==a[j+1][i]) {					// 사고 3
					cnt++;
				}else {
					cnt=1;
				}
				if(cnt>=3) {								// 사고 4
					System.out.println("제거대상의 번호는: "+a[j][i]);
					ers = a[j][i];
					for (int k = j-1; k < a.length; k++) {
						if(a[k][i]==ers) {
							System.out.println("좌표는 "+k+", "+i);
						}else {
							j = k-1;	// 사고 6
							cnt=1;		// 사고 5
							break;
						}
					}
				}
			}
		System.out.println();
		cnt=1;
		ers=0;
		}
	}

}
